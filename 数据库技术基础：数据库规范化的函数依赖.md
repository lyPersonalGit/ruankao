
函数依赖（Functional Dependency, FD）是数据库规范化的核心概念，用于描述数据属性之间的依赖关系。理解函数依赖是掌握 1NF、2NF、3NF 等范式的关键。以下通过简单例子和逻辑推导，详细讲解函数依赖。

---

### **1. 函数依赖的基本定义**
**定义**：  

如果在一个关系（表）中，属性组（或单个属性）X 的值能唯一确定属性组 Y 的值，则称 **Y 函数依赖于 X**，记作 **X → Y**。  

• **X** 称为 **决定因子（Determinant）**  

• **Y** 称为 **被决定因子（Dependent）**

**通俗解释**：  

如果知道 X 的值，就能唯一确定 Y 的值，那么 Y 函数依赖于 X。  

例如：通过学生的学号（X），可以唯一确定他的姓名（Y），即 **学号 → 姓名**。

---

### **2. 函数依赖的类型**
#### **(1) 完全函数依赖（Full Functional Dependency）**
• **定义**：如果 Y 函数依赖于 X，且 Y 不函数依赖于 X 的任何真子集（即 X 的所有属性都是必要的）。  

• **示例**：  

  表：`成绩表（学号, 课程号, 成绩）`  

  • 主键：`(学号, 课程号)`  

  • **完全依赖**：`(学号, 课程号) → 成绩`  

​    解释：成绩由学号和课程号共同决定，缺少任何一个都无法唯一确定成绩。

#### **(2) 部分函数依赖（Partial Functional Dependency）**
• **定义**：如果 Y 函数依赖于 X，但 Y 也可以函数依赖于 X 的某个真子集（即 X 中存在冗余属性）。  

• **示例**：  

  表：`学生表（学号, 姓名, 学院, 学院地址）`  

  • 主键：`学号`  

  • **部分依赖**：`学号 → 学院地址`  

​    问题：学院地址实际上由学院决定（`学院 → 学院地址`），而学院又由学号决定，因此存在传递依赖。

#### **(3) 传递函数依赖（Transitive Functional Dependency）**
• **定义**：如果存在非主属性 Z，使得 `X → Y` 且 `Y → Z`，则称 Z 传递依赖于 X。  

• **示例**：  

  表：`学生表（学号, 学院, 学院地址）`  

  • 主键：`学号`  

  • 传递依赖：`学号 → 学院 → 学院地址`  

​    问题：学院地址不是直接由学号决定，而是通过学院传递决定的。

---

### **3. 函数依赖的判定方法**
#### **(1) 根据语义分析**  
通过业务逻辑直接判断依赖关系。  

• 例如：`学号 → 姓名`（一个学号对应唯一姓名）。

#### **(2) 根据数据推导**  
观察数据中的重复模式。  

• 示例：  

| 学号                                                  | 课程号 | 成绩 | 课程名   |
| ----------------------------------------------------- | ------ | ---- | -------- |
| 101                                                   | C001   | 90   | 数据库   |
| 101                                                   | C002   | 85   | 操作系统 |
| • 推导出：`课程号 → 课程名`（课程号唯一决定课程名）。 |        |      |          |

#### **(3) 键（Key）的关联**  
• **候选键**：能唯一标识元组的属性组。  

• **主键**：从候选键中选出的一个作为主标识符。  

• **非主属性**：不包含在候选键中的属性。

---

### **4. 函数依赖与规范化的关系**
规范化的过程就是通过消除不良函数依赖（部分依赖、传递依赖）来优化数据库设计。

#### **(1) 1NF（消除非原子值）**  
• 确保所有属性都是原子的，与函数依赖无关，但为后续范式提供基础。

#### **(2) 2NF（消除部分依赖）**  
• **规则**：所有非主属性必须完全函数依赖于候选键。  

• **示例**：  

  • 表：`订单明细（订单号, 产品号, 数量, 客户名）`  

  • 问题：`客户名` 只依赖于 `订单号`（部分依赖）。  

  • 解决方案：拆分为 `订单表（订单号, 客户名）` 和 `订单明细表（订单号, 产品号, 数量）`。

#### **(3) 3NF（消除传递依赖）**  
• **规则**：所有非主属性必须直接函数依赖于候选键，不能传递依赖。  

• **示例**：  

  • 表：`学生表（学号, 学院, 学院地址）`  

  • 问题：`学院地址` 传递依赖于 `学号`（学号 → 学院 → 学院地址）。  

  • 解决方案：拆分为 `学生表（学号, 学院）` 和 `学院表（学院, 学院地址）`。

---

### **5. 函数依赖的 Armstrong 公理**
用于推导函数依赖的逻辑规则：  
1. **自反律（Reflexivity）**：若 Y ⊆ X，则 X → Y。  

   • 例如：`(学号, 姓名) → 学号`  

2. **增广律（Augmentation）**：若 X → Y，则 XZ → YZ。  

   • 例如：若 `学号 → 姓名`，则 `(学号, 课程号) → (姓名, 课程号)`  

3. **传递律（Transitivity）**：若 X → Y 且 Y → Z，则 X → Z。  

   • 例如：若 `学号 → 学院` 且 `学院 → 学院地址`，则 `学号 → 学院地址`  

---

### **6. 实际案例分析**
#### **案例：员工信息表**
初始表：  
| 员工ID | 姓名 | 部门   | 部门经理 | 工资等级 | 基本工资 |
| ------ | ---- | ------ | -------- | -------- | -------- |
| E001   | 张三 | 技术部 | 李经理   | G5       | 15000    |
| E002   | 李四 | 财务部 | 王经理   | G4       | 12000    |

**函数依赖分析**：  
1. **员工ID → 姓名, 部门, 部门经理, 工资等级, 基本工资**  
2. **部门 → 部门经理**（部门决定部门经理）  
3. **工资等级 → 基本工资**（工资等级决定基本工资）  

**问题**：  

• 传递依赖：`员工ID → 部门 → 部门经理`  

• 传递依赖：`员工ID → 工资等级 → 基本工资`  

**规范化到3NF**：  
1. **员工表**：`员工ID, 姓名, 部门, 工资等级`  
2. **部门表**：`部门, 部门经理`  
3. **工资表**：`工资等级, 基本工资`  

---

### **7. 总结**
• **函数依赖**是数据属性之间的逻辑关系，是规范化的理论基础。  

• **关键类型**：完全依赖、部分依赖、传递依赖。  

• **规范化目标**：通过分解表消除不良依赖，减少冗余，避免数据异常（插入、更新、删除异常）。  

• **实际应用**：结合业务语义分析依赖关系，逐步实现 1NF → 2NF → 3NF。

理解函数依赖后，可以更清晰地设计出高效、灵活的数据库结构！