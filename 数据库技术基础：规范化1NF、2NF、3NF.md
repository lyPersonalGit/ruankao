
好的，让我们通过一个订单系统的例子说明数据库规范化的三个范式（1NF、2NF、3NF）：

### 原始表（未规范化）
| 订单号 | 客户 | 产品      | 数量 | 单价 | 客户经理 | 经理电话   |
| ------ | ---- | --------- | ---- | ---- | -------- | ---------- |
| 1001   | 张三 | 手机,耳机 | 2,1  | 5000 | 李经理   | 1380000001 |
| 1002   | 李四 | 平板      | 1    | 3000 | 王经理   | 1380000002 |

---

### 1NF（第一范式）
**要求**：消除重复组，确保每列的原子性



**问题**：

- "产品"和"数量"字段包含多个值

- 同一订单的多条产品信息被压缩在一行

**规范化后**：
| 订单号 | 客户 | 产品 | 数量 | 单价 | 客户经理 | 经理电话   |
| ------ | ---- | ---- | ---- | ---- | -------- | ---------- |
| 1001   | 张三 | 手机 | 2    | 5000 | 李经理   | 1380000001 |
| 1001   | 张三 | 耳机 | 1    | 200  | 李经理   | 1380000001 |
| 1002   | 李四 | 平板 | 1    | 3000 | 王经理   | 1380000002 |

**改进**：

- 每行对应一个产品
- 所有字段都是单一值

---

### 2NF（第二范式）
**要求**：消除部分依赖（非主属性必须完全依赖主键）



**问题**：
- 主键是（订单号 + 产品）
- "客户"和"客户经理"只依赖订单号（部分依赖）
- "单价"只依赖产品（部分依赖）

**拆分表**：



**订单表**

| 订单号 | 客户 | 客户经理 | 经理电话   |
| ------ | ---- | -------- | ---------- |
| 1001   | 张三 | 李经理   | 1380000001 |
| 1002   | 李四 | 王经理   | 1380000002 |

**订单明细表**
| 订单号 | 产品 | 数量 | 单价 |
| ------ | ---- | ---- | ---- |
| 1001   | 手机 | 2    | 5000 |
| 1001   | 耳机 | 1    | 200  |
| 1002   | 平板 | 1    | 3000 |

**产品表**
| 产品 | 单价 |
| ---- | ---- |
| 手机 | 5000 |
| 耳机 | 200  |
| 平板 | 3000 |

**改进**：
- 订单信息与产品信息分离
- 单价只存储在产品表中

---

### 3NF（第三范式）
**要求**：消除传递依赖（非主属性不能依赖其他非主属性）



**问题**：
- 经理电话依赖客户经理，而客户经理又依赖订单号（传递依赖）

**进一步拆分**：



**订单表**
| 订单号 | 客户 | 客户经理 |
| ------ | ---- | -------- |
| 1001   | 张三 | 李经理   |
| 1002   | 李四 | 王经理   |

**客户经理表**
| 客户经理 | 经理电话   |
| -------- | ---------- |
| 李经理   | 1380000001 |
| 王经理   | 1380000002 |

**改进**：
- 经理电话独立存储
- 更新经理电话时只需修改一处

---

### 最终规范化结构
1. **订单表**（订单号 PK，客户，客户经理）
2. **订单明细表**（订单号 + 产品 PK，数量）
3. **产品表**（产品 PK，单价）
4. **客户经理表**（客户经理 PK，经理电话）

**好处**：
- 消除数据冗余（如经理电话只存一次）
- 避免更新异常（如修改单价不影响历史订单）
- 防止插入/删除异常（可单独添加产品信息）

通过这个例子，可以看到规范化如何逐步解决数据冗余和依赖问题，最终得到一个灵活、高效的数据结构。