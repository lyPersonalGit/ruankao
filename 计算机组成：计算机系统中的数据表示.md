
在计算机系统中，数据表示是数值运算和存储的基础。以下是原码、反码、补码和移码的详细介绍：

---

### 一、原码（Sign-Magnitude）
#### 定义
- 最高位为符号位（0表示正数，1表示负数），其余位表示数值的绝对值。
- **示例**：
  - +5 的8位原码：`00000101`
  - -5 的8位原码：`10000101`

#### 特点
- **优点**：直观，与人类理解的符号数值一致。
- **缺点**：
  - 加减运算复杂（需判断符号位）；
  - 存在两种零的表示（+0和-0），如：`00000000`和`10000000`。

#### 应用
- 早期计算机系统或简单硬件设计中使用。

---

### 二、反码（Ones' Complement）
#### 定义
- **正数**的反码与原码相同；
- **负数**的反码：符号位不变，其余位按位取反。
- **示例**：
  - +5 的反码：`00000101`
  - -5 的反码：`11111010`

#### 特点
- **优点**：简化了部分运算逻辑。
- **缺点**：
  - 仍然存在两种零的表示；
  - 加减运算需处理进位循环问题（如 `11111111 + 1 = 00000000`）。

#### 应用
- 早期计算机系统（如CDC 6000系列）。

---

### 三、补码（Two's Complement）
#### 定义
- **正数**的补码与原码相同；
- **负数**的补码：反码加1（或原码符号位不变，其余位取反后加1）。
- **示例**：
  - +5 的补码：`00000101`
  - -5 的补码：`11111011`

#### 特点
- **优点**：
  - 统一了零的表示（只有`00000000`）；
  - 加减运算无需处理符号位，硬件实现简单。
- **缺点**：负数范围比正数多一个（如8位补码范围：-128~+127）。

#### 应用
- **现代计算机系统**的整数表示标准。

---

### 四、移码（Excess-K / Bias）
#### 定义
- 将数值整体偏移一个固定值（K），使所有数值转换为非负数。
- **公式**：移码 = 真值 + K（通常取 \( K = 2^{n-1} - 1 \)，如8位移码的K=127）。
- **示例**（K=127）：
  - +5 的移码：`127 + 5 = 132` → 二进制 `10000100`
  - -5 的移码：`127 - 5 = 122` → 二进制 `01111010`

#### 特点
- **优点**：便于比较数值大小（按无符号数直接比较即可）；
- **缺点**：不直接参与算术运算。

#### 应用
- **浮点数中的指数部分**（如IEEE 754标准）。

---

### 五、总结对比
| 编码 | 符号处理                  | 零的表示 | 运算复杂度 | 典型应用场景       |
| ---- | ------------------------- | -------- | ---------- | ------------------ |
| 原码 | 符号位 + 绝对值           | 两种零   | 高         | 早期系统           |
| 反码 | 符号位 + 按位取反         | 两种零   | 中         | 历史系统           |
| 补码 | 符号位 + 按位取反 +1      | 单一零   | 低         | 现代计算机整数存储 |
| 移码 | 真值 + 偏移量（转为非负） | 无符号   | 不参与运算 | 浮点数指数部分     |

---

### 关键理解
1. **补码**通过消除“零的歧义”和统一加减法逻辑，成为计算机整数运算的核心。
2. **移码**通过偏移量简化了浮点数指数的比较。
3. 原码和反码因运算复杂或硬件成本高，已逐渐被淘汰。